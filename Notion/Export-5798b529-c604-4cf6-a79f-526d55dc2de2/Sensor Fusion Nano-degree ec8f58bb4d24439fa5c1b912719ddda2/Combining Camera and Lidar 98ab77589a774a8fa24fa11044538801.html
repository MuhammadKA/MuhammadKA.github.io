<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Combining Camera and Lidar</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="98ab7758-9a77-4a8f-a24f-a11044538801" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">6️⃣</span></div><h1 class="page-title">Combining Camera and Lidar</h1></header><div class="page-body"><h1 id="ae77861c-f389-47f1-94c9-739e676bcf77" class=""><strong>Lidar-to-Camera Point Projection</strong></h1><h3 id="4fb16532-ca50-41cc-b037-e5271be9cb0a" class=""><strong>Overview</strong></h3><p id="475a2304-79c1-4a2d-8ebb-af4b2d587240" class="">Until now, we have used either a camera or a Lidar sensor to track objects. The main problem with a single-sensor approach is its reduced reliability as each sensor has its weaknesses under certain situations. In this lesson, you will learn how to properly combine camera and Lidar to improve the tracking process results.</p><p id="7f777117-490e-4258-b472-76347575ae60" class="">The first step in the fusion process will be to combine the tracked feature points within the camera images with the 3D Lidar points. To do this, we need to geometrically project the Lidar points into the camera in such a way that we know the position of each 3D Lidar point on the image sensor.</p><p id="f1ab9529-6fca-450d-99f2-4b4e18b94eec" class="">To do this, we need to use the knowledge you gained in the lesson on cameras and transformation matrices. You will also learn about the concept of <code>homogeneous coordinates</code>, which makes the transformations (and there will be many) really easy from a computational perspective: Instead of solving lengthy equations, you can simply concatenate a number of vector-matrix-multiplications and be done with the point projection. This concept significantly facilitates the coding process.</p><p id="626b9239-a8ee-48fc-9690-e093ebe0ebc4" class="">One of the most interesting aspects of this section is introducing a deep-learning algorithm that can identify vehicles (and other objects) in images. You will learn the basics and the proper usage of this algorithm, and we will use the resulting bounding boxes around all vehicles in an image to properly cluster and combine 2D feature tracks and 3D lidar points.</p><p id="3e527a36-d038-4ee6-a7c8-a0f0e31e04b3" class="">Finally, I will show you how to make the step from 2D feature tracks, and 3D Lidar points to 3D vehicle tracks, which will be the proper input for TTC computation. By completing this lesson, you will have the basis for completing the final project of the course.</p><ul id="2c7a7f01-3a8a-410d-952d-4204004cb975" class="bulleted-list"><li>Detecting vehicles in the camera image using DL is mandatory to cluster lidar point cloud into separate objects</li></ul><h2 id="91173044-e88d-4f8c-bfbb-b9fa6476866c" class=""><strong>Why is this section important for you?</strong></h2><p id="bd0155cd-2dcc-452a-8fea-d22f60a3f689" class="">This section will enable you to properly combine 2D image data with 3D Lidar data. You will use your knowledge on camera geometry to project 3D points in space onto the 2D image sensor. To do so efficiently, you need to learn about a concept called <code>homogeneous coordinates</code>, which greatly simplifies the projection equations you need to program in your code. Also, you will be introduced to the prototype vehicle called “KITTI” that has been used to collect the sensor data we have been using throughout the course.</p><h2 id="1c8ddfb2-693c-47af-888e-6f17c597df69" class=""><strong>Displaying and Cropping Lidar Points</strong></h2><p id="3c119cd3-7466-4ee6-a7fc-1a2d6779d528" class="">In this section, we will load a set of Lidar points from the file and display it from a top view perspective. Also, we will manually remove points that are located in the road surface. This is an important step which is needed to correctly compute the time-to-collision in the final project. The Lidar points have been obtained using a Velodyne HDL-64E sensor spinning at a frequency of 10Hz and capturing approximately 100k points per cycle. Further information on the KITTI sensor setup can be found here : <a href="http://www.cvlibs.net/datasets/kitti/setup.php"><strong>http://www.cvlibs.net/datasets/kitti/setup.php</strong></a></p><figure id="fc054d2b-37f3-444b-956a-67daf12c302f" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled.png"><img style="width:700px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled.png"/></a></figure><p id="10b7c3b5-43ad-4226-b609-710c8bcb323b" class="">As will be detailed later, the Velodyne sensor has been synchronized with a forward-looking camera, which, at the time of capturing the Lidar data used in this section, was showing the following (by now very familiar) scene.</p><figure id="5a72c0cf-61f3-4878-9b33-ed671f8daba4" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%201.png"><img style="width:1242px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%201.png"/></a></figure><p id="b3369480-81b6-412c-9a3f-366f8cc3cd54" class="">The Lidar points corresponding to the scene are displayed in the following figure, together with the Velodyne coordinate system and a set of distance markers. While the top view image has been cropped at 20m, the farthest point for this scene in the original dataset is at ~78m.</p><figure id="1c8d1d74-5724-49f2-9c3e-b0d56a63587d" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%202.png"><img style="width:3914px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%202.png"/></a></figure><h2 id="12181eff-2285-4a46-966b-470b9b6db879" class=""><strong>Exercise</strong></h2><p id="5d39b4ca-14a4-44a3-acad-b8500a9d5983" class="">The following code in <code>show_lidar_top_view.cpp</code> loads and displays the Lidar points in a top view perspective. When you run the code example, you will see that all Lidar points are displayed, including the ones on the road surface. Please complete the following exercises before continuing:</p><ol id="f0de3ca1-ab04-482e-89bc-88bd6c1222aa" class="numbered-list" start="1"><li>Change the color of the Lidar points such that X=0.0m corresponds to red while X=20.0m is shown as green with a gradual transition in between. The output of the Lidar point cloud should look like this:</li></ol><figure id="5bc301c7-94a9-4c17-ae9e-b14eb484abe0" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%203.png"><img style="width:3916px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%203.png"/></a></figure><p id="8c015829-bb39-45d6-a28c-2159714a44a6" class="">Remove all Lidar points on the road surface while preserving measurements on the obstacles in the scene. Your final result should look something like this:</p><figure id="c5c55b0d-9bd2-4e8f-8261-f9ea19d17a50" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%204.png"><img style="width:3916px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%204.png"/></a></figure><p id="19a92cae-10d6-44b0-81bd-cdb8471eeaac" class="">Now that we can display Lidar data as 3D points in the sensor coordinate system, let us move on to the next section, where we want to start working on a way to project these points onto the camera image.</p><h2 id="84062117-1901-41a6-ab61-69a8226c7c7c" class="">Merging Camera with Lidar Points</h2><p id="85c6a9a6-15ae-4e8a-86ac-44448e06e5d7" class="">The easiest thing to do is to merge the 3D Lidar points into the camera image, but you need to make sure that:</p><ul id="92922c94-7b7f-4d91-a7db-c4f56d4faa6e" class="bulleted-list"><li>You synchronize all your lidar measurements to the exact recording time stamp of the camera</li></ul><ul id="d5c3851a-a6c6-4f31-804f-4e1c507946b8" class="bulleted-list"><li>If your camera is moving (that is typically the case for a robot), you compensate for that motion artifact. Because a typical lidar takes 100 ms to scan, and in that time you traveled a bit, and you need to compensate that motion so that the 3D point of the lidar falls exactly to the right pixel on the image. </li></ul><h1 id="123e634e-fe0c-43a6-bf5f-6287df5aae53" class="">Object Detection with YOLO</h1><p id="3a7dceb4-d8ec-4bca-a1b9-ecd27c28fdd2" class="">Until now, we are able to track 2D image features, measure 3D Lidar points and project them onto the image sensor. However, in order to achieve a stable TTC estimate in the final algorithm, it is not sufficient to observe single points. Instead, we need to cluster points that fall onto the same vehicle and discard those that are not relevant to our task (e.g. points on the road surface).</p><p id="f0c11201-c381-4c11-8ea1-7ff7fac24548" class="">To do so, we need a way to reliably identify vehicles in our images and to place a bounding box around them. This section will introduce you to a deep-learning algorithm named YOLO (“You Only Look Once”) that is able to detect a range of various objects, including vehicles, pedestrians and several others. By the end of the section, you will be able to properly use the YOLO algorithm in your code for AI-based object detection.</p><p id="6415fdd7-e802-48a5-ad2d-cb8f3dd7d9d1" class="">We need a way to detect vehicles in our images so that we can isolate matched keypoints as well as projected Lidar points and associate them to a specific object. Let us take a look at the program flow schematic we already discussed in the lesson on engineering a collision detection system.</p><figure id="21c40b5d-4f15-45e9-897b-4e62596a1916" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%205.png"><img style="width:2188px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%205.png"/></a></figure><p id="680b1b2c-9abc-4468-b35d-057f57d6ea9f" class="">Based on what you learned in the previous lesson, you are now able to detect and match keypoints using a variety of detectors and descriptors. In order to compute the time-to-collision for a specific vehicle however, we need to isolate the keypoints on that vehicle so that TTC estimation is not distorted due to the inclusion of matches on e.g. the road surface, stationary objects or other vehicles in the scene. One way to achieve this is to automatically identify the vehicles in the scene using object detection. The output of such an algorithm would (ideally) be a set of 2D bounding boxes around all objects in the scene. Based on these bounding boxes, we could then easily associate keypoint matches to objects and achieve a stable TTC estimate.</p><p id="1e8e12c0-588b-47a5-81c8-bf41f0908741" class="">For the Lidar measurements, the same rationale can be applied. As you have learned in the previous course on Lidar, you already know that 3D points can be successfully clustered into individual objects, e.g. by using algorithms from the Point Cloud Library (PCL), which can be seen as an equivalent to the OpenCV library for 3D applications. In this section, let us look at yet another approach to group Lidar points into objects. Based on what you learned in the previous section, you now know how to project Lidar points onto the image plane. Given a set of bounding boxes from object detection, we could thus easily associate a 3D Lidar point to a specific object in a scene by simply checking whether it is enclosed by a bounding box when projected into the camera.</p><p id="f85cbfb6-36a4-4896-a3a8-a62b88a8c650" class="">We will look in detail at both of the described approaches later in this section but for now, let us look at a way to detect objects in camera images - which is a prerequisite for grouping keypoint matches as well as Lidar points. in the schematic shown above, the content of the current lesson is highlighted by a blue rectangle and in this section we will be focussing on &#x27;detecting &amp; classifying objects‘.</p><h2 id="67bd2d1a-5a09-4faa-a0d9-56b0d4fa4d22" class=""><strong>Introduction into YOLO</strong></h2><p id="82166fd3-1024-4ba2-865e-6a879fb75bb3" class="">The aim of this section is to enable you to quickly leverage a powerful and state-of-the-art tool for object detection. It is not the purpose to perform a theoretical deep-dive into the inner workings of such algorithms, but rather you should be enabled to integrate object detection into the code framework of this course quickly and seamlessly. The following image shows the an example output of the code we will be developing in this section.</p><figure id="ac19acb3-c9e2-4ebf-8837-ab802bdd3ec3" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%206.png"><img style="width:1152px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%206.png"/></a></figure><p id="a9001482-23bc-4077-816e-0ab3bb712daf" class="">In the past, methods for object detection were often based on histograms of oriented gradients (HOG) and support vector machines (SVM). Until the advent of deep-learning, the HOG/SVM approach was long considered the state-of-the-art approach to detection. While the results of HOG/SVM are still acceptable for a large variety of problems, its use on platforms with limited processing speed is limited. As with SIFT, one of the major issues is the methods reliance on the intensity gradient - which is a costly operation.</p><p id="cc772251-74fb-4f04-afce-7ee448b18b34" class="">Another approach to object detection is the use of deep-learning frameworks such as TensorFlow or Caffe. However, the learning curve for both is very steep and would warrant an entire course on its own. An easy-to-use alternative that works right out of the box and is also based on similar underlying concepts is YOLO, a very fast detection framework that is shipped with the OpenCV library. Developed by Joseph Redmon, Santosh Divvala, Ross Girshick, and Ali Farhadi at Cornell University, YOLO uses a different approach than most other methods: Here, a single neural network is applied to the full image. This network divides the image into regions and predicts bounding boxes and probabilities for each region. These bounding boxes are weighted by the predicted probabilities. The following figure illustrates the principle:</p><figure id="070215fb-97d7-423a-8674-7435ea6b4af4" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%207.png"><img style="width:1733px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%207.png"/></a><figcaption>Source: <a href="https://github.com/pjreddie/darknet/wiki/YOLO:-Real-Time-Object-Detection">https://github.com/pjreddie/darknet/wiki/YOLO:-Real-Time-Object-Detection</a></figcaption></figure><p id="5502a177-ca15-4a71-a46e-d0117951897f" class="">Other than classifier-based systems such as HOG/SVM, YOLO looks at the whole image so its predictions are informed by global context in the image. It also makes predictions with a single network pass unlike systems like R-CNN which require thousands of passes for a single image. This makes it extremely fast while at the same time generating similar results as other state-of-the-art methods such as the Single Shot MultiBox Detector (SSD).</p><p id="4ef74ec3-de75-4359-8d8a-93feaa7b270a" class="">The makers of YOLO have also made available a set of pre-trained weights that enable the current version YOLOv3 to recognize 80 different objects in images and videos based on COCO (<a href="http://cocodataset.org/#home">http://cocodataset.org/#home</a>) , which is a is large-scale object detection, segmentation, and captioning dataset. In the context of this course this means, that we can use YOLOv3 as an out-of-the-box classifier which is able to detect vehicles (and many other obstacles) with reasonable accuracy.</p><h1 id="372db525-f9e7-43bf-8137-2d5da9cdbdbf" class="">Standard CV vs Deep Learning</h1><p id="bdc4e495-7368-4a31-bdf8-a319991ef7cc" class="">It still makes a lot of sense to learn the classical computer vision algorithms like half transforms, color spaces, edge detection. No everything has to be done with deep learning. </p><p id="73791785-d746-47ae-bd23-6cb1da45e0f9" class="">It is Okay to pre-train DNN with simulated data because you can just have a vast amount of data to pre-train. But, it is really hard to simulate the characteristics and noise models precisely to the chip that you want to have on your target vehicle. So, you will not get around with just training data in simulation. You will have to add annotated real data on the top. </p><h1 id="9bbadd17-93c5-47bf-99f1-44401e05ae7b" class="">Creating 3D-Objects</h1><p id="fc66d1a2-75d2-4f6a-b160-966cca204a9f" class="">In this last section before the final project, you will learn how to combine 2D image features, 3D Lidar points and 2D YOLO-based vehicle bounding boxes to produce a stable 3D trajectory of a preceding vehicle. This will be the basis for creating a robust implementation of the TTC algorithm you have already learned about in a previous lesson.</p><h2 id="b32d7d45-7f93-4bc3-809a-98c457e747e1" class=""><strong>Grouping Lidar Points Using a Region of Interest</strong></h2><p id="83f4ebc0-0ee5-411c-b273-23b25540ebf2" class="">The goal of this section is to group Lidar points that belong to the same physical object in the scene. To do this, we will make use of the camera-based object detection method we investigated in the last section. By using the YOLOv3 framework, we can extract a set of objects from a camera image that are represented by an enclosing rectangle (a &quot;region of interest&quot; or ROI) as well as a class label that identifies the type of object, e.g. a vehicle.</p><p id="f1b52ed7-6eff-42c4-b7ef-0c9649459b2a" class="">In the following, we will make use of the ROI to associate 3D Lidar points in space with 2D objects in the camera image. As can be seen in the following image, the idea is to project all Lidar points onto the image plane using calibration data and camera view geometry. By cycling through all Lidar points contained in the current data buffer in an outer loop and through all ROI in an inner loop, a test can be performed to check whether a Lidar point belongs to a specific bounding box.</p><figure id="c05e986e-e3cb-4ce7-ad2c-9ec3f25b134c" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%208.png"><img style="width:2482px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%208.png"/></a></figure><p id="cb220863-b789-428b-b6ff-0538498583cc" class="">If a Lidar point has been found to be within a ROI, it is added to the BoundingBox data structure we have seen in the previous section on object detection with YOLO. The BoundingBox structure introduced there now contains the following elements:</p><pre id="c5fa1ee7-28ee-464b-9c5a-492ebdcb5c04" class="code"><code>struct BoundingBox { // bounding box around a classified object (contains both 2D and 3D data)
int boxID; // unique identifier for this bounding box
int trackID; // unique identifier for the track to which this bounding box belongs

cv::Rect roi; // 2D region-of-interest in image coordinates
int classID; // ID based on class file provided to YOLO framework
double confidence; // classification trust

std::vector&lt;LidarPoint&gt; lidarPoints; // Lidar 3D points which project into 2D image roi
std::vector&lt;cv::KeyPoint&gt; keypoints; // keypoints enclosed by 2D roi
std::vector&lt;cv::DMatch&gt; kptMatches; // keypoint matches enclosed by 2D roi
};</code></pre><p id="4f82bb9a-490b-4846-a5d2-1bc878484d46" class="">During object detection, the members &quot;boxID&quot;, &quot;roi&quot;, &quot;classID&quot; and &quot;confidence&quot; have been filled with data. During Lidar point grouping in this section, the member &quot;lidarPoints&quot; is filled with all points within the boundaries of the respective ROI rectangle. In terms of the image shown above, this means that all colored Lidar points which have been projected into the camera image are associated with the green rectangle which encloses them. Lidar points not enclosed by a rectangle are ignored.</p><p id="b25cfdbd-020c-436e-ad72-559d4d1d36ea" class="">In some cases, object detection returns ROI that are too large and thus overlap into parts of the scene that are not a part of the enclosed object (e.g. a neighboring vehicle or the road surface). It is therefore advisable to adjust the size of the ROI slightly so that the number of Lidar points which are not physically located on the object is reduced. The following code shows how this can be achieved without much effort.</p><pre id="f6619005-3167-4c29-9553-086a7bb37f83" class="code"><code>vector&lt;vector&lt;BoundingBox&gt;::iterator&gt; enclosingBoxes; // pointers to all bounding boxes which enclose the current Lidar point
for (vector&lt;BoundingBox&gt;::iterator it2 = boundingBoxes.begin(); it2 != boundingBoxes.end(); ++it2)
{
    // shrink current bounding box slightly to avoid having too many outlier points around the edges
    cv::Rect smallerBox;
    smallerBox.x = (*it2).roi.x + shrinkFactor * (*it2).roi.width / 2.0;
    smallerBox.y = (*it2).roi.y + shrinkFactor * (*it2).roi.height / 2.0;
    smallerBox.width = (*it2).roi.width * (1 - shrinkFactor);
    smallerBox.height = (*it2).roi.height * (1 - shrinkFactor);
}</code></pre><p id="1e73a68a-023c-4b69-8aa9-ab733f004c6d" class="">By providing a factor &quot;shrinkFactor &#x27;&#x27; which denotes the amount of resizing in [% ], a smaller box is created from the original bounding box. Further down in the code (see final project student code for details), a check is performed for each keypoint whether it belongs to the smaller bounding box. The figure below shows two different settings for &quot;shrinkFactor&quot;. It can be seen that for the second figure, the projected Lidar points are concentrated on the central area of the preceding vehicle whereas Lidar points close to the edges are ignored.</p><figure id="bae7cdae-feab-4a29-beb5-cb319ade5498" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%209.png"><img style="width:642px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%209.png"/></a></figure><p id="27ed50f7-1609-43f3-a333-6f85cf883bad" class="">In practice, a moderate setting of 5-10% should be used to avoid discarding too much data. In some cases, when the bounding boxes returned by object detection are severely oversized, this process of boundary frame shrinkage can be an important tool to improve the quality of the associated Lidar point group.</p><h2 id="89e582ad-99fe-4d65-be9c-7a15b31082c0" class="">Exercise: Avoiding Grouping Errors</h2><p id="2ff26be0-fda4-42be-9ae0-d4a64dd4f975" class="">Another potential problem in addition to oversized regions of interest is their strictly rectangular shape, which rarely fits the physical outline of the enclosed objects. As can be seen in the figure at the very top of this section, the two vehicles in the left lane exhibit a significant overlap in their regions of interest.</p><p id="9229639d-5510-468c-90c1-a37961f204a9" class="">During point cloud association, Lidar points located on one vehicle might inadvertently be associated with another other vehicle. In the example illustrated in the figure below, a set of Lidar points in the upper right corner of the green ROI that actually belong to the red truck are associated with the blue vehicle. In the top view perspective on the left, this error becomes clearly visible.</p><figure id="f49ef4c0-ef20-4aa8-9b7d-88a75174cc08" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%2010.png"><img style="width:1248px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%2010.png"/></a></figure><p id="23e98f7c-0f97-46de-b8df-aa9ea56518ed" class="">In the following code example you will find the algorithm that is responsible for this incorrect behavior.</p><p id="48df253b-3e57-4caa-a17f-ef625f459925" class="">Your task now is to make changes to this code in such a way that Lidar points enclosed within multiple bounding boxes are excluded from further processing. We will lose some points but on the other hand you will get clean 3D objects. </p><p id="b27e79f6-1867-4b43-806f-960ffa75cfdc" class="">You can find the code in the workspace below in <code>cluster_with_roi.cpp</code>, and after making, you can run the code using the executable <code>cluster_with_roi</code>.</p><figure id="cc9e03ef-dfbd-4df8-88eb-33bfa701a88e" class="image"><a href="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%2011.png"><img style="width:620px" src="Combining%20Camera%20and%20Lidar%2098ab77589a774a8fa24fa11044538801/Untitled%2011.png"/></a></figure><ul id="7b5c2505-e875-427d-9fff-da07764c995e" class="bulleted-list"><li>At the far end of scanning area, we do pick other points belonging to another vehicle into our bounding box. This is something we can&#x27;t so easily avoid, at least not by image processing alone. We could run some algorithm on the lidar point cloud itself and look for spacial proximity. </li></ul><h1 id="dac38110-0e8d-428b-8816-e63c17270e1d" class="">Verify the Reliability of Sensor Fusion System</h1><p id="4bc533d7-c113-40bd-b7f8-1a2a25a30887" class="">for everything that can go wrong, there must be a safety measure and a backup plan. Develop according to standards and code rules. </p><p id="400a0397-b9f3-4150-92b8-9e10be7f89e4" class="">The sensor fusion module is right at the core and interacts with the rest of the robotic stack. You have upstream your perception modules and downstream your planning module. Sensor Fusion system have to be the component that brings everything together. You need to understand a lot about perception and how perception algorithms work, but you also have to understand the downstream applications of what is planning want to do with the data, how do you want to predict objects into the future. 
All of this has to be brought together in the right way. </p><p id="dc659a07-b7d4-484e-a402-9f772baf7b88" class="">
</p></div></article></body></html>